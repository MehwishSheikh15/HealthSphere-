/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most collections,
 *              with doctors being able to manage their own profiles. It prioritizes
 *              security and data integrity while allowing for rapid prototyping.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Only the authenticated user can
 *                     read or write their own profile.
 * - /doctors/{doctorId}: Stores doctor profile information. Doctors can manage their
 *                         own profiles.
 * - /appointments/{appointmentId}: Stores appointment data. Access control is based on
 *                                   the doctorId and patientId fields.
 * - /transactions/{transactionId}: Stores transaction data related to appointments.
 *                                   Access control is based on appointment participants.
 * - /wallets/{walletId}: Stores wallet information for doctors. Only the doctor can
 *                         access their own wallet.
 * - /reminders/{reminderId}: Stores reminders for users. Only the user can manage
 *                           their own reminders.
 * - /subscriptions/{subscriptionId}: Stores subscription information for users.
 *                                     Only the user can manage their own subscriptions.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed to protect user privacy.
 * - Doctor listing is implicitly allowed via `allow get, list: if true;` since all doctor profiles should be considered public.
 * - In the event of ambiguity, a strict owner-only access model is enforced.
 *
 * Denormalization for Authorization:
 * - Doctor and patient IDs are included in appointment and transaction documents to
 *   avoid needing to perform expensive `get()` operations on the `/users` and `/doctors`
 *   collections during security rule evaluation.
 *
 * Structural Segregation:
 * - User and doctor profiles are stored in separate collections (/users and /doctors)
 *   to enforce different access control policies.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId - The user ID to compare against.
     * @return {bool} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     * @param {string} userId - The user ID to compare against.
     * @return {bool} True if the user IDs match and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rule for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their own profile: request.auth.uid == 'user123'
     * @allow (get) User with UID 'user123' can get their profile: request.auth.uid == 'user123'
     * @allow (update) User with UID 'user123' can update their profile: request.auth.uid == 'user123'
     * @allow (delete) User with UID 'user123' can delete their profile: request.auth.uid == 'user123'
     * @deny (create) User with UID 'user456' cannot create a profile with ID 'user123': request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is disallowed.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for the /doctors/{doctorId} collection.
     * @path /doctors/{doctorId}
     * @allow (create) Doctor with UID 'doctor123' can create their profile: request.auth.uid == 'doctor123'
     * @allow (get) Any user can get a doctor's profile.
     * @allow (list) Any user can list doctors' profiles.
     * @allow (update) Doctor with UID 'doctor123' can update their profile: request.auth.uid == 'doctor123'
     * @allow (delete) Doctor with UID 'doctor123' can delete their profile: request.auth.uid == 'doctor123'
     * @deny (create) User with UID 'user456' cannot create a doctor profile with ID 'doctor123': request.auth.uid != 'doctor123'
     * @principle Enforces document ownership for writes. Allows public read access to doctor profiles.
     */
    match /doctors/{doctorId} {
      allow get, list: if true;
      allow create: if isOwner(doctorId) && request.resource.data.id == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Rule for the /appointments/{appointmentId} collection.
     * @path /appointments/{appointmentId}
     * @allow (create) Any signed-in user can create an appointment.
     * @allow (get) Any signed-in user can get an appointment if they are the doctor or the patient.
     * @allow (list) Any signed-in user can list appointments if they are the doctor or the patient.
     * @allow (update) Only the doctor or the patient can update the appointment.
     * @allow (delete) Only the doctor or the patient can delete the appointment.
     * @deny (create) Anonymous user cannot create an appointment.
     * @principle Allows doctors and patients to manage their appointments.
     */
    match /appointments/{appointmentId} {
      allow get, list: if isSignedIn() && (resource.data.doctorId == request.auth.uid || resource.data.patientId == request.auth.uid);
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.doctorId) || isExistingOwner(resource.data.patientId);
      allow delete: if isExistingOwner(resource.data.doctorId) || isExistingOwner(resource.data.patientId);
    }

    /**
     * @description Rule for the /transactions/{transactionId} collection.
     * @path /transactions/{transactionId}
     *  @allow (get) Any signed-in user can get a transaction if they are the doctor or the patient.
     *  @allow (list) Any signed-in user can list transactions if they are the doctor or the patient.
     * @deny (create) No one can create a transaction directly.
     * @deny (update) No one can update a transaction directly.
     * @deny (delete) No one can delete a transaction directly.
     * @principle Transactions are created and managed by the backend only.
     */
    match /transactions/{transactionId} {
      allow get, list: if isSignedIn() && (resource.data.doctorId == request.auth.uid || resource.data.patientId == request.auth.uid);
      allow create, update, delete: if false;
    }

    /**
     * @description Rule for the /wallets/{walletId} collection.
     * @path /wallets/{walletId}
     * @allow (create) Doctor with UID 'doctor123' can create their wallet: request.auth.uid == 'doctor123'
     * @allow (get) Doctor with UID 'doctor123' can get their wallet: request.auth.uid == 'doctor123'
     * @allow (update) Doctor with UID 'doctor123' can update their wallet: request.auth.uid == 'doctor123'
     * @allow (delete) Doctor with UID 'doctor123' can delete their wallet: request.auth.uid == 'doctor123'
     * @deny (create) User with UID 'user456' cannot create a wallet with ID 'wallet123': request.auth.uid != 'doctor123'
     * @principle Enforces document ownership for writes.
     */
    match /wallets/{walletId} {
      allow get: if isOwner(resource.data.doctorId);
      allow list: if false;
      allow create: if isOwner(resource.data.doctorId) && request.resource.data.doctorId == walletId;
      allow update: if isExistingOwner(resource.data.doctorId) && request.resource.data.doctorId == resource.data.doctorId;
      allow delete: if isExistingOwner(resource.data.doctorId);
    }

    /**
     * @description Rule for the /reminders/{reminderId} collection.
     * @path /reminders/{reminderId}
     * @allow (create) User with UID 'user123' can create a reminder for themselves: request.auth.uid == 'user123'
     * @allow (get) User with UID 'user123' can get their own reminder: request.auth.uid == 'user123'
     * @allow (update) User with UID 'user123' can update their own reminder: request.auth.uid == 'user123'
     * @allow (delete) User with UID 'user123' can delete their own reminder: request.auth.uid == 'user123'
     * @deny (create) User with UID 'user456' cannot create a reminder for user 'user123': request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /reminders/{reminderId} {
      allow get: if isOwner(resource.data.userId);
      allow list: if isOwner(resource.data.userId);
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rule for the /subscriptions/{subscriptionId} collection.
     * @path /subscriptions/{subscriptionId}
     * @allow (create) User with UID 'user123' can create their own subscription: request.auth.uid == 'user123'
     * @allow (get) User with UID 'user123' can get their own subscription: request.auth.uid == 'user123'
     * @allow (update) User with UID 'user123' can update their own subscription: request.auth.uid == 'user123'
     * @allow (delete) User with UID 'user123' can delete their own subscription: request.auth.uid == 'user123'
     * @deny (create) User with UID 'user456' cannot create a subscription for user 'user123': request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /subscriptions/{subscriptionId} {
      allow get: if isOwner(resource.data.userId);
      allow list: if false; // Subscription listing is disallowed.
      allow create: if isOwner(resource.data.userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId);
    }
  }
}