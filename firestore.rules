/**
 * @fileoverview Firestore Security Rules for HealthSphere.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant, user-ownership model. Most data is scoped
 * to a specific user or doctor, identified by their Firebase Auth UID.  Write
 * access is generally restricted to the owning user, while read access may be
 * public in some cases (e.g., listing doctors).
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.  userId matches the Firebase Auth UID.
 * - /doctors/{doctorId}: Stores doctor profiles. doctorId matches the Firebase Auth UID.
 * - /appointments/{appointmentId}: Stores appointment data.
 * - /transactions/{transactionId}: Stores transaction data related to appointments.
 * - /wallets/{walletId}: Stores wallet data for doctors. walletId likely corresponds to the doctorId.
 * - /reminders/{reminderId}: Stores reminder data for users.
 * - /subscriptions/{subscriptionId}: Stores subscription data for users.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Doctor listing is public, but doctor creation is restricted.
 * - The rules explicitly deny any write operation that attempts to modify a document
 *   without proper authorization.
 *
 * Denormalization for Authorization:
 * The rules rely on the `patientId` and `doctorId` fields within the `appointments`
 * collection to enforce access control.  This avoids needing to perform costly
 * `get()` operations to retrieve user roles or other authorization data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to user profile information.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their own profile.
     * @allow (get, list, update, delete) User with matching UID can read/write their own profile.
     * @deny (create) User cannot create a profile with a mismatched UID.
     * @deny (update, delete) User cannot modify or delete another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
      }

      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Allows public read access to doctor profiles, but restricts creation, updates, and deletions.
     * @path /doctors/{doctorId}
     * @allow (get, list) Any user can read doctor profiles.
     * @deny (create, update, delete) Only authorized users (e.g., admins) can create, update, or delete doctor profiles.
     * @principle Public read, owner-only write.
     */
    match /doctors/{doctorId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(doctorId) {
        return request.auth.uid == doctorId;
      }

      function isExistingOwner(doctorId) {
        return isOwner(doctorId) && exists(/databases/$(database)/documents/doctors/$(doctorId));
      }

      allow get, list: if true; // Public read
      allow create: if false; // TODO: add admin user check
      allow update: if isSignedIn() && isOwner(doctorId); // TODO: add admin user check
      allow delete: if isSignedIn() && isOwner(doctorId); // TODO: add admin user check
    }

    /**
     * @description Allows patients and doctors to create appointments, and restricts access to those appointments.
     * @path /appointments/{appointmentId}
     * @allow (create) Patient can create appointments if the `patientId` matches their UID.
     * @allow (get, list) Patient or Doctor can read and list appointments for which they are a participant.
     * @allow (update, delete) Only the assigned patient or doctor can modify the appointment.
     * @deny (create) Patient cannot create appointments for other users.
     * @deny (update, delete) Other users cannot modify or delete an appointment.
     * @principle Enforces access based on patientId and doctorId.
     */
    match /appointments/{appointmentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isPatient(patientId) {
        return request.auth.uid == patientId;
      }

      function isDoctor(doctorId) {
        return request.auth.uid == doctorId;
      }

      function isParticipant(patientId, doctorId) {
        return isPatient(patientId) || isDoctor(doctorId);
      }

      function isExistingParticipant(appointmentId) {
        return exists(/databases/$(database)/documents/appointments/$(appointmentId));
      }

      allow get, list: if isSignedIn() && (resource.data.patientId == request.auth.uid || resource.data.doctorId == request.auth.uid);
      allow create: if isSignedIn() && request.resource.data.patientId == request.auth.uid;
      allow update: if isSignedIn() && (request.resource.data.patientId == request.auth.uid || request.resource.data.doctorId == request.auth.uid);
      allow delete: if isSignedIn() && (resource.data.patientId == request.auth.uid || resource.data.doctorId == request.auth.uid);
    }

    /**
     * @description Allows access to transaction information related to appointments.
     * @path /transactions/{transactionId}
     */
    match /transactions/{transactionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows access to wallet information for doctors.
     * @path /wallets/{walletId}
     */
    match /wallets/{walletId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(walletId) {
        return request.auth.uid == walletId;
      }

      function isExistingOwner(walletId) {
        return isOwner(walletId) && exists(/databases/$(database)/documents/wallets/$(walletId));
      }

      allow get, list: if isSignedIn() && isOwner(walletId);
      allow create: if isSignedIn() && isOwner(walletId);
      allow update: if isSignedIn() && isOwner(walletId);
      allow delete: if isSignedIn() && isOwner(walletId);
    }

    /**
     * @description Allows access to reminder information for users.
     * @path /reminders/{reminderId}
     */
    match /reminders/{reminderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(reminderId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/reminders/$(reminderId));
      }
        allow get, list: if isSignedIn() && resource.data.userId == request.auth.uid;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Allows access to subscription information for users.
     * @path /subscriptions/{subscriptionId}
     */
    match /subscriptions/{subscriptionId} {
      function isSignedIn() {
        return request.auth != null;
      }

       function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(subscriptionId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/subscriptions/$(subscriptionId));
      }
        allow get, list: if isSignedIn() && resource.data.userId == request.auth.uid;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow delete: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    }
  }
}