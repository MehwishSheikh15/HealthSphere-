/**
 * @fileoverview Firestore Security Rules for HealthSphere application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-only access model for user-specific data and a shared access model for collaborative data.
 * It focuses on preventing unauthorized data access and modification.
 *
 * Data Structure:
 * - /users/{userId}: Stores personal user data, accessible only to the user.
 * - /doctors/{doctorId}: Stores doctor profile data, accessible only to the doctor.
 * - /appointments/{appointmentId}: Stores appointment data, accessible to participating doctor and patient.
 * - /transactions/{transactionId}: Stores transaction data, accessible to participating doctor and patient.
 * - /wallets/{walletId}: Stores wallet data, accessible only to the associated doctor.
 * - /reminders/{reminderId}: Stores reminder data, accessible only to the user who set the reminder.
 * - /subscriptions/{subscriptionId}: Stores subscription data, accessible only to the user who owns the subscription.
 *
 * Key Security Decisions:
 * - User listing is disallowed across all collections to protect privacy.
 * - All write operations require user authentication.
 * - Data validation is minimal in this prototyping phase, focusing on authorization.
 *
 * Denormalization for Authorization:
 * The rules leverage denormalization by assuming the presence of `patientId` and `doctorId` in the `appointments` and `transactions` collections to grant/restrict access based on user roles.
 *
 * Structural Segregation:
 * User and doctor profiles are stored in separate collections (`/users` and `/doctors`) to maintain a clear security posture for each.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants access to user profiles only to the authenticated user.
     * @path /databases/{database}/documents/users/{userId}
     * @allow (create) User with UID 'user123' can create their own profile.
     * @allow (get) User with UID 'user123' can read their own profile.
     * @allow (update) User with UID 'user123' can update their own profile.
     * @allow (delete) User with UID 'user123' can delete their own profile.
     * @deny (create) User with UID 'user123' cannot create a profile for 'user456'.
     * @deny (get) User with UID 'user123' cannot read the profile of 'user456'.
     * @deny (update) User with UID 'user123' cannot update the profile of 'user456'.
     * @deny (delete) User with UID 'user123' cannot delete the profile of 'user456'.
     * @principle Enforces strict user-ownership for profile data.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Grants access to doctor profiles only to the authenticated doctor.
     * @path /databases/{database}/documents/doctors/{doctorId}
     * @allow (create) Doctor with UID 'doctor123' can create their own profile.
     * @allow (get) Doctor with UID 'doctor123' can read their own profile.
     * @allow (update) Doctor with UID 'doctor123' can update their own profile.
     * @allow (delete) Doctor with UID 'doctor123' can delete their own profile.
     * @deny (create) User with UID 'user123' cannot create a doctor profile for 'doctor456'.
     * @deny (get) User with UID 'user123' cannot read the profile of 'doctor456'.
     * @deny (update) User with UID 'user123' cannot update the profile of 'doctor456'.
     * @deny (delete) User with UID 'user123' cannot delete the profile of 'doctor456'.
     * @principle Enforces strict doctor-ownership for profile data.
     */
    match /doctors/{doctorId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(doctorId) {
        return request.auth.uid == doctorId;
      }

      function isExistingOwner(doctorId) {
        return isSignedIn() && isOwner(doctorId) && resource.data.doctorId == doctorId;
      }

      allow get: if true; // Doctors are public and searchable.
      allow list: if true; // Doctors are public and searchable.

      allow create: if isSignedIn() && isOwner(doctorId);
      allow update: if isExistingOwner(doctorId);
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Grants access to appointments to the participating doctor and patient.
     * @path /databases/{database}/documents/appointments/{appointmentId}
     * @allow (create) Doctor/Patient with UID 'user123' can create appointments.
     * @allow (get) Doctor/Patient with UID 'user123' can read appointment if either doctorId or patientId matches.
     * @allow (update) Doctor/Patient with UID 'user123' can update appointment if either doctorId or patientId matches.
     * @allow (delete) Doctor/Patient with UID 'user123' can delete appointment if either doctorId or patientId matches.
     * @deny (create) User with UID 'user123' cannot create appointment for other users.
     * @deny (get) User with UID 'user123' cannot read appointment if neither doctorId nor patientId matches.
     * @deny (update) User with UID 'user123' cannot update appointment if neither doctorId nor patientId matches.
     * @deny (delete) User with UID 'user123' cannot delete appointment if neither doctorId nor patientId matches.
     * @principle Enforces shared access for appointments based on doctorId and patientId.
     */
    match /appointments/{appointmentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(appointment) {
          return appointment.patientId == request.auth.uid || appointment.doctorId == request.auth.uid;
      }

        function isExistingParticipant(appointment) {
        return isSignedIn() && isParticipant(resource.data);
      }


      allow get: if isExistingParticipant(resource.data);
      allow list: if false; //Fixed based on the reported error. Listing appointments is not enabled for all users. It must happen under the /users/{userId}/appointments collection.


      allow create: if isSignedIn() && (request.resource.data.patientId == request.auth.uid || request.resource.data.doctorId == request.auth.uid);
      allow update: if isExistingParticipant(resource.data);
      allow delete: if isExistingParticipant(resource.data);
    }

    /**
     * @description Grants access to transactions to the participating doctor and patient.
     * @path /databases/{database}/documents/transactions/{transactionId}
     * @allow (create) Doctor/Patient with UID 'user123' can create transactions.
     * @allow (get) Doctor/Patient with UID 'user123' can read transaction if either doctorId or patientId matches.
     * @allow (update) Doctor/Patient with UID 'user123' can update transaction if either doctorId or patientId matches.
     * @allow (delete) Doctor/Patient with UID 'user123' can delete transaction if either doctorId or patientId matches.
     * @deny (create) User with UID 'user123' cannot create transaction for other users.
     * @deny (get) User with UID 'user123' cannot read transaction if neither doctorId nor patientId matches.
     * @deny (update) User with UID 'user123' cannot update transaction if neither doctorId nor patientId matches.
     * @deny (delete) User with UID 'user123' cannot delete transaction if neither doctorId nor patientId matches.
     * @principle Enforces shared access for transactions based on doctorId and patientId.
     */
    match /transactions/{transactionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(transaction) {
        return transaction.patientId == request.auth.uid || transaction.doctorId == request.auth.uid;
      }

      function isExistingParticipant(transaction) {
        return isSignedIn() && isParticipant(resource.data);
      }

      allow get: if isExistingParticipant(resource.data);
      allow list: if false;

      allow create: if isSignedIn() && (request.resource.data.patientId == request.auth.uid || request.resource.data.doctorId == request.auth.uid);
      allow update: if isExistingParticipant(resource.data);
      allow delete: if isExistingParticipant(resource.data);
    }

    /**
     * @description Grants access to wallets only to the associated doctor.
     * @path /databases/{database}/documents/wallets/{walletId}
     * @allow (create) Doctor with UID 'doctor123' can create their own wallet.
     * @allow (get) Doctor with UID 'doctor123' can read their own wallet.
     * @allow (update) Doctor with UID 'doctor123' can update their own wallet.
     * @allow (delete) Doctor with UID 'doctor123' can delete their own wallet.
     * @deny (create) User with UID 'user123' cannot create a wallet for 'doctor456'.
     * @deny (get) User with UID 'user123' cannot read the wallet of 'doctor456'.
     * @deny (update) User with UID 'user123' cannot update the wallet of 'doctor456'.
     * @deny (delete) User with UID 'user123' cannot delete the wallet of 'doctor456'.
     * @principle Enforces strict doctor-ownership for wallet data.
     */
    match /wallets/{walletId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(wallet) {
        return wallet.doctorId == request.auth.uid;
      }

      function isExistingOwner(wallet) {
        return isSignedIn() && isOwner(resource.data);
      }

      allow get: if isExistingOwner(resource.data);
      allow list: if false;

      allow create: if isSignedIn() && request.resource.data.doctorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data);
      allow delete: if isExistingOwner(resource.data);
    }

    /**
     * @description Grants access to reminders only to the user who created them.
     * @path /databases/{database}/documents/reminders/{reminderId}
     * @allow (create) User with UID 'user123' can create their own reminder.
     * @allow (get) User with UID 'user123' can read their own reminder.
     * @allow (update) User with UID 'user123' can update their own reminder.
     * @allow (delete) User with UID 'user123' can delete their own reminder.
     * @deny (create) User with UID 'user123' cannot create a reminder for 'user456'.
     * @deny (get) User with UID 'user123' cannot read the reminder of 'user456'.
     * @deny (update) User with UID 'user123' cannot update the reminder of 'user456'.
     * @deny (delete) User with UID 'user123' cannot delete the reminder of 'user456'.
     * @principle Enforces strict user-ownership for reminder data.
     */
    match /reminders/{reminderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(reminder) {
        return reminder.userId == request.auth.uid;
      }

      function isExistingOwner(reminder) {
        return isSignedIn() && isOwner(resource.data);
      }

      allow get: if isExistingOwner(resource.data);
      allow list: if false;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data);
      allow delete: if isExistingOwner(resource.data);
    }

    /**
     * @description Grants access to subscriptions only to the user who owns the subscription.
     * @path /databases/{database}/documents/subscriptions/{subscriptionId}
     * @allow (create) User with UID 'user123' can create their own subscription.
     * @allow (get) User with UID 'user123' can read their own subscription.
     * @allow (update) User with UID 'user123' can update their own subscription.
     * @allow (delete) User with UID 'user123' can delete their own subscription.
     * @deny (create) User with UID 'user123' cannot create a subscription for 'user456'.
     * @deny (get) User with UID 'user123' cannot read the subscription of 'user456'.
     * @deny (update) User with UID 'user123' cannot update the subscription of 'user456'.
     * @deny (delete) User with UID 'user123' cannot delete the subscription of 'user456'.
     * @principle Enforces strict user-ownership for subscription data.
     */
    match /subscriptions/{subscriptionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(subscription) {
        return subscription.userId == request.auth.uid;
      }

      function isExistingOwner(subscription) {
        return isSignedIn() && isOwner(resource.data);
      }

      allow get: if isExistingOwner(resource.data);
      allow list: if false;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data);
      allow delete: if isExistingOwner(resource.data);
    }
  }
}