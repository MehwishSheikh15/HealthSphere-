/**
 * @fileoverview Firestore Security Rules for HealthSphere.
 *
 * Core Philosophy:
 * This ruleset prioritizes security and data ownership. Users can only access their own data,
 * while doctors and admins have specific, role-based access to appointments and related data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data; accessible only by the user.
 * - /doctors/{doctorId}: Stores doctor profile data; publicly readable, writable only by the doctor.
 * - /appointments/{appointmentId}: Stores appointment data; accessible to the patient and doctor involved.
 * - /transactions/{transactionId}: Stores transaction data; accessible to the patient, doctor and admin.
 * - /wallets/{walletId}: Stores wallet data for doctors, accessible only by the doctor and admin.
 * - /reminders/{reminderId}: Stores reminders, only accessible by the user.
 * - /subscriptions/{subscriptionId}: Stores subscription data, accessible only by the user.
 *
 * Key Security Decisions:
 * - Users cannot list other users.
 * - Doctor profiles are publicly readable to facilitate discovery.
 * - The `appointments` collection enforces granular access based on `patientId` and `doctorId`.
 *
 * Denormalization for Authorization:
 * - Appointment documents should contain both `patientId` and `doctorId` fields, enabling rules to quickly
 *   verify access for both parties without additional reads.
 *
 * Structural Segregation:
 * - User and doctor profiles are stored in separate collections to enforce different access policies.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants access to user-specific data.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile.
     * @deny (create) User with UID 'user123' cannot create a profile with ID 'otherUser'.
     * @allow (get, update, delete, list) User with UID 'user123' can read, update, delete, and list their profile.
     * @deny (get, update, delete, list) User with UID 'user456' cannot access data for user 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow get, update, delete: if isOwner(userId) && resource.data.id == userId;
      allow list: if isOwner(userId);
    }

    /**
     * @description Grants read access to all for doctor profiles, but restricts write access to the doctor.
     * @path /doctors/{doctorId}
     * @allow (get, list) Anyone can view doctor profiles.
     * @allow (create, update, delete) Doctor with UID 'doctor123' can create, update, and delete their own profile.
     * @deny (create, update, delete) User with UID 'user123' cannot modify doctor profiles.
     * @principle Allows public read access to doctor profiles while enforcing ownership for writes.
     */
    match /doctors/{doctorId} {
        function isOwner(doctorId) {
            return request.auth != null && request.auth.uid == doctorId;
        }
        allow get, list: if true;
        allow create, update, delete: if isOwner(doctorId) && resource.data.id == doctorId;
    }

    /**
     * @description Grants access to appointments for both the patient and the doctor involved.
     * @path /appointments/{appointmentId}
     * @allow (get, list) Patient 'patient123' or doctor 'doctor456' can access appointments where they are participants.
     * @allow (create) Patient 'patient123' can create an appointment with doctor 'doctor456'.
     * @allow (update, delete) Patient 'patient123' or doctor 'doctor456' can update or delete appointments where they are participants.
     * @deny (get, list, create, update, delete) User 'otherUser' cannot access appointments they are not a part of.
     * @principle Enforces shared access based on the `patientId` and `doctorId` fields.
     */
    match /appointments/{appointmentId} {
        function isParticipant(patientId, doctorId) {
            return request.auth != null && (request.auth.uid == patientId || request.auth.uid == doctorId);
        }

        function isExistingParticipant(patientId, doctorId) {
          return isParticipant(patientId, doctorId) && resource != null;
        }

        allow get: if isParticipant(resource.data.patientId, resource.data.doctorId);
        allow list: if request.auth.uid != null;
        allow create: if request.auth != null && (request.resource.data.patientId == request.auth.uid || request.resource.data.doctorId == request.auth.uid);
        allow update, delete: if isExistingParticipant(resource.data.patientId, resource.data.doctorId);
    }

    /**
     * @description Grants access to transactions for the patient and doctor involved.
     * @path /transactions/{transactionId}
     *  @allow (get, list) Patient 'patient123' or doctor 'doctor456' can access transactions where they are participants.
     * @allow (create) Patient 'patient123' can create a transaction with doctor 'doctor456'.
     * @allow (update, delete) Patient 'patient123' or doctor 'doctor456' can update or delete transactions where they are participants.
     * @deny (get, list, create, update, delete) User 'otherUser' cannot access transactions they are not a part of.
     * @principle Enforces shared access based on the `patientId` and `doctorId` fields.
     */
    match /transactions/{transactionId} {
      function isParticipant(patientId, doctorId) {
          return request.auth != null && (request.auth.uid == patientId || request.auth.uid == doctorId);
      }

      function isExistingParticipant(patientId, doctorId) {
        return isParticipant(patientId, doctorId) && resource != null;
      }

      allow get: if isParticipant(resource.data.patientId, resource.data.doctorId);
      allow list: if request.auth.uid != null;
      allow create: if request.auth != null && (request.resource.data.patientId == request.auth.uid || request.resource.data.doctorId == request.auth.uid);
      allow update, delete: if isExistingParticipant(resource.data.patientId, resource.data.doctorId);
    }

    /**
     * @description Grants access to wallets only for the doctor who owns the wallet.
     * @path /wallets/{walletId}
     * @allow (get, list, update, delete) Doctor 'doctor123' can access and modify their own wallet.
     * @deny (get, list, update, delete) User 'user123' cannot access doctor wallets.
     * @principle Enforces strict ownership for wallet data.
     */
    match /wallets/{walletId} {
        function isOwner(doctorId) {
            return request.auth != null && request.auth.uid == doctorId;
        }

        function isExistingOwner(doctorId) {
          return isOwner(doctorId) && resource != null;
        }

        allow get, list: if isOwner(resource.data.doctorId);
        allow create: if false;
        allow update, delete: if isExistingOwner(resource.data.doctorId);
    }

    /**
     * @description Grants access to reminders only for the user who owns the reminder.
     * @path /reminders/{reminderId}
     * @allow (get, list, update, delete) User 'user123' can access and modify their own reminders.
     * @deny (get, list, update, delete) User 'user456' cannot access reminders for user 'user123'.
     * @principle Enforces strict ownership for reminder data.
     */
    match /reminders/{reminderId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(resource.data.userId);
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Grants access to subscriptions only for the user who owns the subscription.
     * @path /subscriptions/{subscriptionId}
     * @allow (get, list, update, delete) User 'user123' can access and modify their own subscription.
     * @deny (get, list, update, delete) User 'user456' cannot access subscriptions for user 'user123'.
     * @principle Enforces strict ownership for subscription data.
     */
    match /subscriptions/{subscriptionId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(resource.data.userId);
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.userId);
    }
  }
}